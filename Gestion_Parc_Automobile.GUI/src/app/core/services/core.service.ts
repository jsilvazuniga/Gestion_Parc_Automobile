/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class Service {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    coleur(): Observable<ColeurResponseDto[]> {
        let url_ = this.baseUrl + "/api/Coleur";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processColeur(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processColeur(<any>response_);
                } catch (e) {
                    return <Observable<ColeurResponseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ColeurResponseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processColeur(response: HttpResponseBase): Observable<ColeurResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ColeurResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ColeurResponseDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    marque(): Observable<MarqueResponseDto[]> {
        let url_ = this.baseUrl + "/api/Marque";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarque(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarque(<any>response_);
                } catch (e) {
                    return <Observable<MarqueResponseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MarqueResponseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processMarque(response: HttpResponseBase): Observable<MarqueResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MarqueResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MarqueResponseDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    modele(): Observable<ModeleResponseDto[]> {
        let url_ = this.baseUrl + "/api/Modele";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModele(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModele(<any>response_);
                } catch (e) {
                    return <Observable<ModeleResponseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModeleResponseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processModele(response: HttpResponseBase): Observable<ModeleResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModeleResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModeleResponseDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllReservations(): Observable<ReservationResponseDto[]> {
        let url_ = this.baseUrl + "/api/Reservation/GetAllReservations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllReservations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllReservations(<any>response_);
                } catch (e) {
                    return <Observable<ReservationResponseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReservationResponseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllReservations(response: HttpResponseBase): Observable<ReservationResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReservationResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReservationResponseDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getMyReservations(): Observable<ReservationResponseDto[]> {
        let url_ = this.baseUrl + "/api/Reservation/GetMyReservations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyReservations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyReservations(<any>response_);
                } catch (e) {
                    return <Observable<ReservationResponseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReservationResponseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyReservations(response: HttpResponseBase): Observable<ReservationResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReservationResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReservationResponseDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createReserve(body: ReservationRequestDto | undefined): Observable<ReservationResponseDto> {
        let url_ = this.baseUrl + "/api/Reservation/CreateReserve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReserve(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReserve(<any>response_);
                } catch (e) {
                    return <Observable<ReservationResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReservationResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateReserve(response: HttpResponseBase): Observable<ReservationResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReservationResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReservationResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    statut(): Observable<StatutResponseDto[]> {
        let url_ = this.baseUrl + "/api/Statut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatut(<any>response_);
                } catch (e) {
                    return <Observable<StatutResponseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatutResponseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processStatut(response: HttpResponseBase): Observable<StatutResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatutResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatutResponseDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    utilisateur(): Observable<UtilisateurResponseDto[]> {
        let url_ = this.baseUrl + "/api/Utilisateur";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUtilisateur(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUtilisateur(<any>response_);
                } catch (e) {
                    return <Observable<UtilisateurResponseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UtilisateurResponseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processUtilisateur(response: HttpResponseBase): Observable<UtilisateurResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UtilisateurResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UtilisateurResponseDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    loginUtilisateur(body: UtilisateurLoginRequestDto | undefined): Observable<TokenResponse> {
        let url_ = this.baseUrl + "/api/Utilisateur/LoginUtilisateur";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginUtilisateur(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginUtilisateur(<any>response_);
                } catch (e) {
                    return <Observable<TokenResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokenResponse>><any>_observableThrow(response_);
        }));
    }

    protected processLoginUtilisateur(response: HttpResponseBase): Observable<TokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenResponse>(<any>null);
    }

    /**
     * @return Success
     */
    obtenirUtilisateurIdentity(): Observable<UtilisateurResponseDto> {
        let url_ = this.baseUrl + "/api/Utilisateur/ObtenirUtilisateurIdentity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenirUtilisateurIdentity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenirUtilisateurIdentity(<any>response_);
                } catch (e) {
                    return <Observable<UtilisateurResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UtilisateurResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processObtenirUtilisateurIdentity(response: HttpResponseBase): Observable<UtilisateurResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UtilisateurResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UtilisateurResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUtilisateur(body: UtilisateurRequestDto | undefined): Observable<UtilisateurResponseDto> {
        let url_ = this.baseUrl + "/api/Utilisateur/CreateUtilisateur";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUtilisateur(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUtilisateur(<any>response_);
                } catch (e) {
                    return <Observable<UtilisateurResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UtilisateurResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUtilisateur(response: HttpResponseBase): Observable<UtilisateurResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UtilisateurResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UtilisateurResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    voiture(): Observable<VoitureResponseDto[]> {
        let url_ = this.baseUrl + "/api/Voiture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoiture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoiture(<any>response_);
                } catch (e) {
                    return <Observable<VoitureResponseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<VoitureResponseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processVoiture(response: HttpResponseBase): Observable<VoitureResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VoitureResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VoitureResponseDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getVoiture(idVoiture: number): Observable<VoitureResponseDto> {
        let url_ = this.baseUrl + "/api/Voiture/GetVoiture/{idVoiture}";
        if (idVoiture === undefined || idVoiture === null)
            throw new Error("The parameter 'idVoiture' must be defined.");
        url_ = url_.replace("{idVoiture}", encodeURIComponent("" + idVoiture));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVoiture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVoiture(<any>response_);
                } catch (e) {
                    return <Observable<VoitureResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VoitureResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVoiture(response: HttpResponseBase): Observable<VoitureResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VoitureResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VoitureResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ajouterVoiture(body: VoitureRequestDto | undefined): Observable<VoitureResponseDto> {
        let url_ = this.baseUrl + "/api/Voiture/AjouterVoiture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAjouterVoiture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAjouterVoiture(<any>response_);
                } catch (e) {
                    return <Observable<VoitureResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VoitureResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processAjouterVoiture(response: HttpResponseBase): Observable<VoitureResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VoitureResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VoitureResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    supprimerVoiture(idVoiture: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Voiture/SupprimerVoiture/{idVoiture}";
        if (idVoiture === undefined || idVoiture === null)
            throw new Error("The parameter 'idVoiture' must be defined.");
        url_ = url_.replace("{idVoiture}", encodeURIComponent("" + idVoiture));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSupprimerVoiture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSupprimerVoiture(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSupprimerVoiture(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    changeKilometrage(idVoiture: number, kilometrage: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Voiture/ChangeKilometrage/{idVoiture}/{kilometrage}";
        if (idVoiture === undefined || idVoiture === null)
            throw new Error("The parameter 'idVoiture' must be defined.");
        url_ = url_.replace("{idVoiture}", encodeURIComponent("" + idVoiture));
        if (kilometrage === undefined || kilometrage === null)
            throw new Error("The parameter 'kilometrage' must be defined.");
        url_ = url_.replace("{kilometrage}", encodeURIComponent("" + kilometrage));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeKilometrage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeKilometrage(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangeKilometrage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export class ColeurResponseDto implements IColeurResponseDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IColeurResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ColeurResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ColeurResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IColeurResponseDto {
    id?: number;
    name?: string | undefined;
}

export class MarqueResponseDto implements IMarqueResponseDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IMarqueResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MarqueResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new MarqueResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IMarqueResponseDto {
    id?: number;
    name?: string | undefined;
}

export class ModeleResponseDto implements IModeleResponseDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IModeleResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ModeleResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModeleResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IModeleResponseDto {
    id?: number;
    name?: string | undefined;
}

export class UtilisateurResponseDto implements IUtilisateurResponseDto {
    id?: number;
    name?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    idProfil?: number;

    constructor(data?: IUtilisateurResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.idProfil = _data["idProfil"];
        }
    }

    static fromJS(data: any): UtilisateurResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UtilisateurResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["idProfil"] = this.idProfil;
        return data; 
    }
}

export interface IUtilisateurResponseDto {
    id?: number;
    name?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    idProfil?: number;
}

export class Statut implements IStatut {
    id!: number;
    name!: string;

    constructor(data?: IStatut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Statut {
        data = typeof data === 'object' ? data : {};
        let result = new Statut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IStatut {
    id: number;
    name: string;
}

export class Modele implements IModele {
    id!: number;
    name!: string;

    constructor(data?: IModele) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Modele {
        data = typeof data === 'object' ? data : {};
        let result = new Modele();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IModele {
    id: number;
    name: string;
}

export class Marque implements IMarque {
    id!: number;
    name!: string;

    constructor(data?: IMarque) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Marque {
        data = typeof data === 'object' ? data : {};
        let result = new Marque();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IMarque {
    id: number;
    name: string;
}

export class Coleur implements IColeur {
    id!: number;
    name!: string;

    constructor(data?: IColeur) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Coleur {
        data = typeof data === 'object' ? data : {};
        let result = new Coleur();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IColeur {
    id: number;
    name: string;
}

export class VoitureResponseDto implements IVoitureResponseDto {
    id?: number;
    name?: string | undefined;
    kilometrage?: number;
    puissance?: number;
    dateMiseEnCirculation?: Date;
    detaille?: string | undefined;
    active?: boolean;
    statut?: Statut;
    modele?: Modele;
    marque?: Marque;
    coleur?: Coleur;

    constructor(data?: IVoitureResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.kilometrage = _data["kilometrage"];
            this.puissance = _data["puissance"];
            this.dateMiseEnCirculation = _data["dateMiseEnCirculation"] ? new Date(_data["dateMiseEnCirculation"].toString()) : <any>undefined;
            this.detaille = _data["detaille"];
            this.active = _data["active"];
            this.statut = _data["statut"] ? Statut.fromJS(_data["statut"]) : <any>undefined;
            this.modele = _data["modele"] ? Modele.fromJS(_data["modele"]) : <any>undefined;
            this.marque = _data["marque"] ? Marque.fromJS(_data["marque"]) : <any>undefined;
            this.coleur = _data["coleur"] ? Coleur.fromJS(_data["coleur"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VoitureResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new VoitureResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["kilometrage"] = this.kilometrage;
        data["puissance"] = this.puissance;
        data["dateMiseEnCirculation"] = this.dateMiseEnCirculation ? this.dateMiseEnCirculation.toISOString() : <any>undefined;
        data["detaille"] = this.detaille;
        data["active"] = this.active;
        data["statut"] = this.statut ? this.statut.toJSON() : <any>undefined;
        data["modele"] = this.modele ? this.modele.toJSON() : <any>undefined;
        data["marque"] = this.marque ? this.marque.toJSON() : <any>undefined;
        data["coleur"] = this.coleur ? this.coleur.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IVoitureResponseDto {
    id?: number;
    name?: string | undefined;
    kilometrage?: number;
    puissance?: number;
    dateMiseEnCirculation?: Date;
    detaille?: string | undefined;
    active?: boolean;
    statut?: Statut;
    modele?: Modele;
    marque?: Marque;
    coleur?: Coleur;
}

export class ReservationResponseDto implements IReservationResponseDto {
    id?: number;
    dateDebut?: Date;
    dateFin?: Date;
    utilisateur?: UtilisateurResponseDto;
    voiture?: VoitureResponseDto;

    constructor(data?: IReservationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateDebut = _data["dateDebut"] ? new Date(_data["dateDebut"].toString()) : <any>undefined;
            this.dateFin = _data["dateFin"] ? new Date(_data["dateFin"].toString()) : <any>undefined;
            this.utilisateur = _data["utilisateur"] ? UtilisateurResponseDto.fromJS(_data["utilisateur"]) : <any>undefined;
            this.voiture = _data["voiture"] ? VoitureResponseDto.fromJS(_data["voiture"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReservationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateDebut"] = this.dateDebut ? this.dateDebut.toISOString() : <any>undefined;
        data["dateFin"] = this.dateFin ? this.dateFin.toISOString() : <any>undefined;
        data["utilisateur"] = this.utilisateur ? this.utilisateur.toJSON() : <any>undefined;
        data["voiture"] = this.voiture ? this.voiture.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IReservationResponseDto {
    id?: number;
    dateDebut?: Date;
    dateFin?: Date;
    utilisateur?: UtilisateurResponseDto;
    voiture?: VoitureResponseDto;
}

export class ReservationRequestDto implements IReservationRequestDto {
    idVoiture?: number;
    dateDebut?: Date;
    dateFin?: Date;

    constructor(data?: IReservationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idVoiture = _data["idVoiture"];
            this.dateDebut = _data["dateDebut"] ? new Date(_data["dateDebut"].toString()) : <any>undefined;
            this.dateFin = _data["dateFin"] ? new Date(_data["dateFin"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ReservationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idVoiture"] = this.idVoiture;
        data["dateDebut"] = this.dateDebut ? this.dateDebut.toISOString() : <any>undefined;
        data["dateFin"] = this.dateFin ? this.dateFin.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IReservationRequestDto {
    idVoiture?: number;
    dateDebut?: Date;
    dateFin?: Date;
}

export class StatutResponseDto implements IStatutResponseDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IStatutResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): StatutResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatutResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IStatutResponseDto {
    id?: number;
    name?: string | undefined;
}

export class UtilisateurLoginRequestDto implements IUtilisateurLoginRequestDto {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IUtilisateurLoginRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UtilisateurLoginRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UtilisateurLoginRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface IUtilisateurLoginRequestDto {
    email?: string | undefined;
    password?: string | undefined;
}

export class TokenResponse implements ITokenResponse {
    access_token?: string | undefined;
    expires?: Date | undefined;

    constructor(data?: ITokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_token = _data["access_token"];
            this.expires = _data["expires"] ? new Date(_data["expires"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITokenResponse {
    access_token?: string | undefined;
    expires?: Date | undefined;
}

export class UtilisateurRequestDto implements IUtilisateurRequestDto {
    id?: number;
    name?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: IUtilisateurRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): UtilisateurRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UtilisateurRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["avatar"] = this.avatar;
        return data; 
    }
}

export interface IUtilisateurRequestDto {
    id?: number;
    name?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    avatar?: string | undefined;
}

export class VoitureRequestDto implements IVoitureRequestDto {
    id?: number;
    name?: string | undefined;
    kilometrage?: number;
    puissance?: number;
    dateMiseEnCirculation?: Date;
    detaille?: string | undefined;
    idStatut?: number | undefined;
    idModele?: number | undefined;
    idMarque?: number | undefined;
    idColeur?: number | undefined;

    constructor(data?: IVoitureRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.kilometrage = _data["kilometrage"];
            this.puissance = _data["puissance"];
            this.dateMiseEnCirculation = _data["dateMiseEnCirculation"] ? new Date(_data["dateMiseEnCirculation"].toString()) : <any>undefined;
            this.detaille = _data["detaille"];
            this.idStatut = _data["idStatut"];
            this.idModele = _data["idModele"];
            this.idMarque = _data["idMarque"];
            this.idColeur = _data["idColeur"];
        }
    }

    static fromJS(data: any): VoitureRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new VoitureRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["kilometrage"] = this.kilometrage;
        data["puissance"] = this.puissance;
        data["dateMiseEnCirculation"] = this.dateMiseEnCirculation ? this.dateMiseEnCirculation.toISOString() : <any>undefined;
        data["detaille"] = this.detaille;
        data["idStatut"] = this.idStatut;
        data["idModele"] = this.idModele;
        data["idMarque"] = this.idMarque;
        data["idColeur"] = this.idColeur;
        return data; 
    }
}

export interface IVoitureRequestDto {
    id?: number;
    name?: string | undefined;
    kilometrage?: number;
    puissance?: number;
    dateMiseEnCirculation?: Date;
    detaille?: string | undefined;
    idStatut?: number | undefined;
    idModele?: number | undefined;
    idMarque?: number | undefined;
    idColeur?: number | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}